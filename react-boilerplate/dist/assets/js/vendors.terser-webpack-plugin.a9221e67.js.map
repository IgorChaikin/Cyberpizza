{"version":3,"file":"assets/js/vendors.terser-webpack-plugin.a9221e67.js","sources":["webpack://react-boilerplate/./node_modules/terser-webpack-plugin/dist/cjs.js","webpack://react-boilerplate/./node_modules/terser-webpack-plugin/dist/index.js","webpack://react-boilerplate/./node_modules/terser-webpack-plugin/dist/minify.js"],"sourcesContent":["\"use strict\";\n\nconst plugin = require(\"./index\");\n\nmodule.exports = plugin.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar path = _interopRequireWildcard(require(\"path\"));\n\nvar os = _interopRequireWildcard(require(\"os\"));\n\nvar _sourceMap = require(\"source-map\");\n\nvar _schemaUtils = require(\"schema-utils\");\n\nvar _serializeJavascript = _interopRequireDefault(require(\"serialize-javascript\"));\n\nvar terserPackageJson = _interopRequireWildcard(require(\"terser/package.json\"));\n\nvar _pLimit = _interopRequireDefault(require(\"p-limit\"));\n\nvar _jestWorker = require(\"jest-worker\");\n\nvar schema = _interopRequireWildcard(require(\"./options.json\"));\n\nvar _minify = require(\"./minify\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/** @typedef {import(\"schema-utils/declarations/validate\").Schema} Schema */\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n\n/** @typedef {import(\"webpack\").Compilation} Compilation */\n\n/** @typedef {import(\"webpack\").WebpackError} WebpackError */\n\n/** @typedef {import(\"webpack\").Asset} Asset */\n\n/** @typedef {import(\"terser\").ECMA} TerserECMA */\n\n/** @typedef {import(\"terser\").MinifyOptions} TerserMinifyOptions */\n\n/** @typedef {import(\"jest-worker\").Worker} JestWorker */\n\n/** @typedef {import(\"source-map\").RawSourceMap} RawSourceMap */\n\n/** @typedef {import(\"./minify.js\").InternalMinifyOptions} InternalMinifyOptions */\n\n/** @typedef {import(\"./minify.js\").InternalMinifyResult} InternalMinifyResult */\n\n/** @typedef {import(\"./minify.js\").CustomMinifyOptions} CustomMinifyOptions */\n\n/** @typedef {RegExp | string} Rule */\n\n/** @typedef {Rule[] | Rule} Rules */\n\n/** @typedef {JestWorker & { transform: (options: string) => InternalMinifyResult, minify: (options: InternalMinifyOptions) => InternalMinifyResult }} MinifyWorker */\n\n/**\n * @callback ExtractCommentsFunction\n * @param {any} astNode\n * @param {{ value: string, type: 'comment1' | 'comment2' | 'comment3' | 'comment4', pos: number, line: number, col: number }} comment\n * @returns {boolean}\n */\n\n/**\n * @typedef {boolean | string | RegExp | ExtractCommentsFunction} ExtractCommentsCondition\n */\n\n/**\n * @typedef {string | ((fileData: any) => string)} ExtractCommentsFilename\n */\n\n/**\n * @typedef {boolean | string | ((commentsFile: string) => string)} ExtractCommentsBanner\n */\n\n/**\n * @typedef {Object} ExtractCommentsObject\n * @property {ExtractCommentsCondition} condition\n * @property {ExtractCommentsFilename} filename\n * @property {ExtractCommentsBanner} banner\n */\n\n/**\n * @callback CustomMinifyFunction\n * @param {{ [file: string]: string }} fileAndCode\n * @param {RawSourceMap} [sourceMap]\n * @param {Object.<any, any>} minifyOptions\n */\n\n/**\n * @typedef {ExtractCommentsCondition | ExtractCommentsObject} ExtractCommentsOptions\n */\n\n/**\n * @typedef {Object} PluginWithTerserOptions\n * @property {Rules} [test]\n * @property {Rules} [include]\n * @property {Rules} [exclude]\n * @property {TerserMinifyOptions} [terserOptions]\n * @property {ExtractCommentsOptions} [extractComments]\n * @property {boolean} [parallel]\n * @property {CustomMinifyFunction} [minify]\n */\n\n/**\n * @typedef {Object} PluginWithCustomMinifyOptions\n * @property {Rules} [test]\n * @property {Rules} [include]\n * @property {Rules} [exclude]\n * @property {Object.<any, any>} [terserOptions]\n * @property {ExtractCommentsOptions} [extractComments]\n * @property {boolean} [parallel]\n * @property {CustomMinifyFunction} [minify]\n */\n\n/**\n * @typedef {PluginWithTerserOptions | PluginWithCustomMinifyOptions} TerserPluginOptions\n */\nclass TerserPlugin {\n  /**\n   * @param {TerserPluginOptions} options\n   */\n  constructor(options = {}) {\n    (0, _schemaUtils.validate)(\n    /** @type {Schema} */\n    schema, options, {\n      name: \"Terser Plugin\",\n      baseDataPath: \"options\"\n    });\n    const {\n      minify,\n      terserOptions = {},\n      test = /\\.[cm]?js(\\?.*)?$/i,\n      extractComments = true,\n      parallel = true,\n      include,\n      exclude\n    } = options;\n    this.options = {\n      test,\n      extractComments,\n      parallel,\n      include,\n      exclude,\n      minify,\n      terserOptions\n    };\n  }\n  /**\n   * @private\n   * @param {any} input\n   * @returns {boolean}\n   */\n\n\n  static isSourceMap(input) {\n    // All required options for `new SourceMapConsumer(...options)`\n    // https://github.com/mozilla/source-map#new-sourcemapconsumerrawsourcemap\n    return Boolean(input && input.version && input.sources && Array.isArray(input.sources) && typeof input.mappings === \"string\");\n  }\n  /**\n   * @private\n   * @param {Error & { line: number, col: number}} error\n   * @param {string} file\n   * @param {Compilation[\"requestShortener\"]} [requestShortener]\n   * @param {SourceMapConsumer} [sourceMap]\n   * @returns {Error}\n   */\n\n\n  static buildError(error, file, requestShortener, sourceMap) {\n    if (error.line) {\n      const original = sourceMap && sourceMap.originalPositionFor({\n        line: error.line,\n        column: error.col\n      });\n\n      if (original && original.source && requestShortener) {\n        return new Error(`${file} from Terser\\n${error.message} [${requestShortener.shorten(original.source)}:${original.line},${original.column}][${file}:${error.line},${error.col}]${error.stack ? `\\n${error.stack.split(\"\\n\").slice(1).join(\"\\n\")}` : \"\"}`);\n      }\n\n      return new Error(`${file} from Terser\\n${error.message} [${file}:${error.line},${error.col}]${error.stack ? `\\n${error.stack.split(\"\\n\").slice(1).join(\"\\n\")}` : \"\"}`);\n    }\n\n    if (error.stack) {\n      return new Error(`${file} from Terser\\n${error.stack}`);\n    }\n\n    return new Error(`${file} from Terser\\n${error.message}`);\n  }\n  /**\n   * @private\n   * @param {boolean} parallel\n   * @returns {number}\n   */\n\n\n  static getAvailableNumberOfCores(parallel) {\n    // In some cases cpus() returns undefined\n    // https://github.com/nodejs/node/issues/19022\n    const cpus = os.cpus() || {\n      length: 1\n    };\n    return parallel === true ? cpus.length - 1 : Math.min(Number(parallel) || 0, cpus.length - 1);\n  }\n  /**\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {Record<string, import(\"webpack\").sources.Source>} assets\n   * @param {{availableNumberOfCores: number}} optimizeOptions\n   * @returns {Promise<void>}\n   */\n\n\n  async optimize(compiler, compilation, assets, optimizeOptions) {\n    const cache = compilation.getCache(\"TerserWebpackPlugin\");\n    let numberOfAssetsForMinify = 0;\n    const assetsForMinify = await Promise.all(Object.keys(assets).filter(name => {\n      const {\n        info\n      } =\n      /** @type {Asset} */\n      compilation.getAsset(name);\n\n      if ( // Skip double minimize assets from child compilation\n      info.minimized || // Skip minimizing for extracted comments assets\n      info.extractedComments) {\n        return false;\n      }\n\n      if (!compiler.webpack.ModuleFilenameHelpers.matchObject.bind( // eslint-disable-next-line no-undefined\n      undefined, this.options)(name)) {\n        return false;\n      }\n\n      return true;\n    }).map(async name => {\n      const {\n        info,\n        source\n      } =\n      /** @type {Asset} */\n      compilation.getAsset(name);\n      const eTag = cache.getLazyHashedEtag(source);\n      const cacheItem = cache.getItemCache(name, eTag);\n      const output = await cacheItem.getPromise();\n\n      if (!output) {\n        numberOfAssetsForMinify += 1;\n      }\n\n      return {\n        name,\n        info,\n        inputSource: source,\n        output,\n        cacheItem\n      };\n    }));\n    /** @type {undefined | (() => MinifyWorker)} */\n\n    let getWorker;\n    /** @type {undefined | MinifyWorker} */\n\n    let initializedWorker;\n    /** @type {undefined | number} */\n\n    let numberOfWorkers;\n\n    if (optimizeOptions.availableNumberOfCores > 0) {\n      // Do not create unnecessary workers when the number of files is less than the available cores, it saves memory\n      numberOfWorkers = Math.min(numberOfAssetsForMinify, optimizeOptions.availableNumberOfCores); // eslint-disable-next-line consistent-return\n\n      getWorker = () => {\n        if (initializedWorker) {\n          return initializedWorker;\n        }\n\n        initializedWorker =\n        /** @type {MinifyWorker} */\n        new _jestWorker.Worker(require.resolve(\"./minify\"), {\n          numWorkers: numberOfWorkers,\n          enableWorkerThreads: true\n        }); // https://github.com/facebook/jest/issues/8872#issuecomment-524822081\n\n        const workerStdout = initializedWorker.getStdout();\n\n        if (workerStdout) {\n          workerStdout.on(\"data\", chunk => process.stdout.write(chunk));\n        }\n\n        const workerStderr = initializedWorker.getStderr();\n\n        if (workerStderr) {\n          workerStderr.on(\"data\", chunk => process.stderr.write(chunk));\n        }\n\n        return initializedWorker;\n      };\n    }\n\n    const limit = (0, _pLimit.default)(getWorker && numberOfAssetsForMinify > 0 ?\n    /** @type {number} */\n    numberOfWorkers : Infinity);\n    const {\n      SourceMapSource,\n      ConcatSource,\n      RawSource\n    } = compiler.webpack.sources;\n    /** @typedef {{ extractedCommentsSource : import(\"webpack\").sources.RawSource, commentsFilename: string }} ExtractedCommentsInfo */\n\n    /** @type {Map<string, ExtractedCommentsInfo>} */\n\n    const allExtractedComments = new Map();\n    const scheduledTasks = [];\n\n    for (const asset of assetsForMinify) {\n      scheduledTasks.push(limit(async () => {\n        const {\n          name,\n          inputSource,\n          info,\n          cacheItem\n        } = asset;\n        let {\n          output\n        } = asset;\n\n        if (!output) {\n          let input;\n          /** @type {RawSourceMap | undefined} */\n\n          let inputSourceMap;\n          const {\n            source: sourceFromInputSource,\n            map\n          } = inputSource.sourceAndMap();\n          input = sourceFromInputSource;\n\n          if (map) {\n            if (TerserPlugin.isSourceMap(map)) {\n              inputSourceMap =\n              /** @type {RawSourceMap} */\n              map;\n            } else {\n              inputSourceMap =\n              /** @type {RawSourceMap} */\n              map;\n              compilation.warnings.push(\n              /** @type {WebpackError} */\n              new Error(`${name} contains invalid source map`));\n            }\n          }\n\n          if (Buffer.isBuffer(input)) {\n            input = input.toString();\n          }\n          /** @type {InternalMinifyOptions} */\n\n\n          const options = {\n            name,\n            input,\n            inputSourceMap,\n            minify: this.options.minify,\n            minifyOptions: { ...this.options.terserOptions\n            },\n            extractComments: this.options.extractComments\n          };\n\n          if (typeof options.minifyOptions.module === \"undefined\") {\n            if (typeof info.javascriptModule !== \"undefined\") {\n              options.minifyOptions.module = info.javascriptModule;\n            } else if (/\\.mjs(\\?.*)?$/i.test(name)) {\n              options.minifyOptions.module = true;\n            } else if (/\\.cjs(\\?.*)?$/i.test(name)) {\n              options.minifyOptions.module = false;\n            }\n          }\n\n          try {\n            output = await (getWorker ? getWorker().transform((0, _serializeJavascript.default)(options)) : (0, _minify.minify)(options));\n          } catch (error) {\n            const hasSourceMap = inputSourceMap && TerserPlugin.isSourceMap(inputSourceMap);\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            TerserPlugin.buildError(error, name, // eslint-disable-next-line no-undefined\n            hasSourceMap ? compilation.requestShortener : undefined, hasSourceMap ? new _sourceMap.SourceMapConsumer(\n            /** @type {RawSourceMap} */\n            inputSourceMap) : // eslint-disable-next-line no-undefined\n            undefined));\n            return;\n          }\n\n          let shebang;\n\n          if (\n          /** @type {ExtractCommentsObject} */\n          this.options.extractComments.banner !== false && output.extractedComments && output.extractedComments.length > 0 && output.code.startsWith(\"#!\")) {\n            const firstNewlinePosition = output.code.indexOf(\"\\n\");\n            shebang = output.code.substring(0, firstNewlinePosition);\n            output.code = output.code.substring(firstNewlinePosition + 1);\n          }\n\n          if (output.map) {\n            output.source = new SourceMapSource(output.code, name, output.map, input,\n            /** @type {RawSourceMap} */\n            inputSourceMap, true);\n          } else {\n            output.source = new RawSource(output.code);\n          }\n\n          if (output.extractedComments && output.extractedComments.length > 0) {\n            const commentsFilename =\n            /** @type {ExtractCommentsObject} */\n            this.options.extractComments.filename || \"[file].LICENSE.txt[query]\";\n            let query = \"\";\n            let filename = name;\n            const querySplit = filename.indexOf(\"?\");\n\n            if (querySplit >= 0) {\n              query = filename.substr(querySplit);\n              filename = filename.substr(0, querySplit);\n            }\n\n            const lastSlashIndex = filename.lastIndexOf(\"/\");\n            const basename = lastSlashIndex === -1 ? filename : filename.substr(lastSlashIndex + 1);\n            const data = {\n              filename,\n              basename,\n              query\n            };\n            output.commentsFilename = compilation.getPath(commentsFilename, data);\n            let banner; // Add a banner to the original file\n\n            if (\n            /** @type {ExtractCommentsObject} */\n            this.options.extractComments.banner !== false) {\n              banner =\n              /** @type {ExtractCommentsObject} */\n              this.options.extractComments.banner || `For license information please see ${path.relative(path.dirname(name), output.commentsFilename).replace(/\\\\/g, \"/\")}`;\n\n              if (typeof banner === \"function\") {\n                banner = banner(output.commentsFilename);\n              }\n\n              if (banner) {\n                output.source = new ConcatSource(shebang ? `${shebang}\\n` : \"\", `/*! ${banner} */\\n`, output.source);\n              }\n            }\n\n            const extractedCommentsString = output.extractedComments.sort().join(\"\\n\\n\");\n            output.extractedCommentsSource = new RawSource(`${extractedCommentsString}\\n`);\n          }\n\n          await cacheItem.storePromise({\n            source: output.source,\n            commentsFilename: output.commentsFilename,\n            extractedCommentsSource: output.extractedCommentsSource\n          });\n        }\n        /** @type {Record<string, any>} */\n\n\n        const newInfo = {\n          minimized: true\n        };\n        const {\n          source,\n          extractedCommentsSource\n        } = output; // Write extracted comments to commentsFilename\n\n        if (extractedCommentsSource) {\n          const {\n            commentsFilename\n          } = output;\n          newInfo.related = {\n            license: commentsFilename\n          };\n          allExtractedComments.set(name, {\n            extractedCommentsSource,\n            commentsFilename\n          });\n        }\n\n        compilation.updateAsset(name, source, newInfo);\n      }));\n    }\n\n    await Promise.all(scheduledTasks);\n\n    if (initializedWorker) {\n      await initializedWorker.end();\n    }\n    /** @typedef {{ source: import(\"webpack\").sources.Source, commentsFilename: string, from: string }} ExtractedCommentsInfoWIthFrom */\n\n\n    await Array.from(allExtractedComments).sort().reduce(\n    /**\n     * @param {Promise<unknown>} previousPromise\n     * @param {[string, ExtractedCommentsInfo]} extractedComments\n     * @returns {Promise<ExtractedCommentsInfoWIthFrom>}\n     */\n    async (previousPromise, [from, value]) => {\n      const previous =\n      /** @type {ExtractedCommentsInfoWIthFrom | undefined} **/\n      await previousPromise;\n      const {\n        commentsFilename,\n        extractedCommentsSource\n      } = value;\n\n      if (previous && previous.commentsFilename === commentsFilename) {\n        const {\n          from: previousFrom,\n          source: prevSource\n        } = previous;\n        const mergedName = `${previousFrom}|${from}`;\n        const name = `${commentsFilename}|${mergedName}`;\n        const eTag = [prevSource, extractedCommentsSource].map(item => cache.getLazyHashedEtag(item)).reduce((previousValue, currentValue) => cache.mergeEtags(previousValue, currentValue));\n        let source = await cache.getPromise(name, eTag);\n\n        if (!source) {\n          source = new ConcatSource(Array.from(new Set([...\n          /** @type {string}*/\n          prevSource.source().split(\"\\n\\n\"), ...\n          /** @type {string}*/\n          extractedCommentsSource.source().split(\"\\n\\n\")])).join(\"\\n\\n\"));\n          await cache.storePromise(name, eTag, source);\n        }\n\n        compilation.updateAsset(commentsFilename, source);\n        return {\n          source,\n          commentsFilename,\n          from: mergedName\n        };\n      }\n\n      const existingAsset = compilation.getAsset(commentsFilename);\n\n      if (existingAsset) {\n        return {\n          source: existingAsset.source,\n          commentsFilename,\n          from: commentsFilename\n        };\n      }\n\n      compilation.emitAsset(commentsFilename, extractedCommentsSource, {\n        extractedComments: true\n      });\n      return {\n        source: extractedCommentsSource,\n        commentsFilename,\n        from\n      };\n    },\n    /** @type {Promise<unknown>} */\n    Promise.resolve());\n  }\n  /**\n   * @private\n   * @param {any} environment\n   * @returns {TerserECMA}\n   */\n\n\n  static getEcmaVersion(environment) {\n    // ES 6th\n    if (environment.arrowFunction || environment.const || environment.destructuring || environment.forOf || environment.module) {\n      return 2015;\n    } // ES 11th\n\n\n    if (environment.bigIntLiteral || environment.dynamicImport) {\n      return 2020;\n    }\n\n    return 5;\n  }\n  /**\n   * @param {Compiler} compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const {\n      output\n    } = compiler.options;\n\n    if (typeof this.options.terserOptions.ecma === \"undefined\") {\n      this.options.terserOptions.ecma = TerserPlugin.getEcmaVersion(output.environment || {});\n    }\n\n    const pluginName = this.constructor.name;\n    const availableNumberOfCores = TerserPlugin.getAvailableNumberOfCores(this.options.parallel);\n    compiler.hooks.compilation.tap(pluginName, compilation => {\n      const hooks = compiler.webpack.javascript.JavascriptModulesPlugin.getCompilationHooks(compilation);\n      const data = (0, _serializeJavascript.default)({\n        terser: terserPackageJson.version,\n        terserOptions: this.options.terserOptions\n      });\n      hooks.chunkHash.tap(pluginName, (chunk, hash) => {\n        hash.update(\"TerserPlugin\");\n        hash.update(data);\n      });\n      compilation.hooks.processAssets.tapPromise({\n        name: pluginName,\n        stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE,\n        additionalAssets: true\n      }, assets => this.optimize(compiler, compilation, assets, {\n        availableNumberOfCores\n      }));\n      compilation.hooks.statsPrinter.tap(pluginName, stats => {\n        stats.hooks.print.for(\"asset.info.minimized\").tap(\"terser-webpack-plugin\", (minimized, {\n          green,\n          formatFlag\n        }) => minimized ?\n        /** @type {Function} */\n        green(\n        /** @type {Function} */\n        formatFlag(\"minimized\")) : \"\");\n      });\n    });\n  }\n\n}\n\nvar _default = TerserPlugin;\nexports.default = _default;","\"use strict\";\n\nconst {\n  minify: terserMinify\n} = require(\"terser\");\n/** @typedef {import(\"source-map\").RawSourceMap} RawSourceMap */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsOptions} ExtractCommentsOptions */\n\n/** @typedef {import(\"./index.js\").CustomMinifyFunction} CustomMinifyFunction */\n\n/** @typedef {import(\"terser\").MinifyOptions} TerserMinifyOptions */\n\n/** @typedef {import(\"terser\").MinifyOutput} MinifyOutput */\n\n/** @typedef {import(\"terser\").FormatOptions} FormatOptions */\n\n/** @typedef {import(\"terser\").MangleOptions} MangleOptions */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsFunction} ExtractCommentsFunction */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsCondition} ExtractCommentsCondition */\n\n/**\n * @typedef {Object.<any, any>} CustomMinifyOptions\n */\n\n/**\n * @typedef {Object} InternalMinifyOptions\n * @property {string} name\n * @property {string} input\n * @property {RawSourceMap} [inputSourceMap]\n * @property {ExtractCommentsOptions} extractComments\n * @property {CustomMinifyFunction} [minify]\n * @property {TerserMinifyOptions | CustomMinifyOptions} minifyOptions\n */\n\n/**\n * @typedef {Array<string>} ExtractedComments\n */\n\n/**\n * @typedef {Promise<MinifyOutput & { extractedComments?: ExtractedComments}>} InternalMinifyResult\n */\n\n/**\n * @typedef {TerserMinifyOptions & { sourceMap: undefined } & ({ output: FormatOptions & { beautify: boolean } } | { format: FormatOptions & { beautify: boolean } })} NormalizedTerserMinifyOptions\n */\n\n/**\n * @param {TerserMinifyOptions} [terserOptions={}]\n * @returns {NormalizedTerserMinifyOptions}\n */\n\n\nfunction buildTerserOptions(terserOptions = {}) {\n  // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n  return { ...terserOptions,\n    compress: typeof terserOptions.compress === \"boolean\" ? terserOptions.compress : { ...terserOptions.compress\n    },\n    // ecma: terserOptions.ecma,\n    // ie8: terserOptions.ie8,\n    // keep_classnames: terserOptions.keep_classnames,\n    // keep_fnames: terserOptions.keep_fnames,\n    mangle: terserOptions.mangle == null ? true : typeof terserOptions.mangle === \"boolean\" ? terserOptions.mangle : { ...terserOptions.mangle\n    },\n    // module: terserOptions.module,\n    // nameCache: { ...terserOptions.toplevel },\n    // the `output` option is deprecated\n    ...(terserOptions.format ? {\n      format: {\n        beautify: false,\n        ...terserOptions.format\n      }\n    } : {\n      output: {\n        beautify: false,\n        ...terserOptions.output\n      }\n    }),\n    parse: { ...terserOptions.parse\n    },\n    // safari10: terserOptions.safari10,\n    // Ignoring sourceMap from options\n    // eslint-disable-next-line no-undefined\n    sourceMap: undefined // toplevel: terserOptions.toplevel\n\n  };\n}\n/**\n * @param {any} value\n * @returns {boolean}\n */\n\n\nfunction isObject(value) {\n  const type = typeof value;\n  return value != null && (type === \"object\" || type === \"function\");\n}\n/**\n * @param {ExtractCommentsOptions} extractComments\n * @param {NormalizedTerserMinifyOptions} terserOptions\n * @param {ExtractedComments} extractedComments\n * @returns {ExtractCommentsFunction}\n */\n\n\nfunction buildComments(extractComments, terserOptions, extractedComments) {\n  /** @type {{ [index: string]: ExtractCommentsCondition }} */\n  const condition = {};\n  let comments;\n\n  if (terserOptions.format) {\n    ({\n      comments\n    } = terserOptions.format);\n  } else if (terserOptions.output) {\n    ({\n      comments\n    } = terserOptions.output);\n  }\n\n  condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n\n  if (typeof extractComments === \"boolean\" && extractComments) {\n    condition.extract = \"some\";\n  } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n    condition.extract = extractComments;\n  } else if (typeof extractComments === \"function\") {\n    condition.extract = extractComments;\n  } else if (extractComments && isObject(extractComments)) {\n    condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n  } else {\n    // No extract\n    // Preserve using \"commentsOpts\" or \"some\"\n    condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n    condition.extract = false;\n  } // Ensure that both conditions are functions\n\n\n  [\"preserve\", \"extract\"].forEach(key => {\n    /** @type {undefined | string} */\n    let regexStr;\n    /** @type {undefined | RegExp} */\n\n    let regex;\n\n    switch (typeof condition[key]) {\n      case \"boolean\":\n        condition[key] = condition[key] ? () => true : () => false;\n        break;\n\n      case \"function\":\n        break;\n\n      case \"string\":\n        if (condition[key] === \"all\") {\n          condition[key] = () => true;\n\n          break;\n        }\n\n        if (condition[key] === \"some\") {\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n\n          break;\n        }\n\n        regexStr =\n        /** @type {string} */\n        condition[key];\n\n        condition[key] =\n        /** @type {ExtractCommentsFunction} */\n        (astNode, comment) => new RegExp(\n        /** @type {string} */\n        regexStr).test(comment.value);\n\n        break;\n\n      default:\n        regex =\n        /** @type {RegExp} */\n        condition[key];\n\n        condition[key] =\n        /** @type {ExtractCommentsFunction} */\n        (astNode, comment) =>\n        /** @type {RegExp} */\n        regex.test(comment.value);\n\n    }\n  }); // Redefine the comments function to extract and preserve\n  // comments according to the two conditions\n\n  return (astNode, comment) => {\n    if (\n    /** @type {{ extract: ExtractCommentsFunction }} */\n    condition.extract(astNode, comment)) {\n      const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n      if (!extractedComments.includes(commentText)) {\n        extractedComments.push(commentText);\n      }\n    }\n\n    return (\n      /** @type {{ preserve: ExtractCommentsFunction }} */\n      condition.preserve(astNode, comment)\n    );\n  };\n}\n/**\n * @param {InternalMinifyOptions} options\n * @returns {InternalMinifyResult}\n */\n\n\nasync function minify(options) {\n  const {\n    name,\n    input,\n    inputSourceMap,\n    minify: minifyFn,\n    minifyOptions\n  } = options;\n\n  if (minifyFn) {\n    return minifyFn({\n      [name]: input\n    }, inputSourceMap, minifyOptions);\n  } // Copy terser options\n\n\n  const terserOptions = buildTerserOptions(minifyOptions); // Let terser generate a SourceMap\n\n  if (inputSourceMap) {\n    // @ts-ignore\n    terserOptions.sourceMap = {\n      asObject: true\n    };\n  }\n  /** @type {ExtractedComments} */\n\n\n  const extractedComments = [];\n  const {\n    extractComments\n  } = options;\n\n  if (terserOptions.output) {\n    terserOptions.output.comments = buildComments(extractComments, terserOptions, extractedComments);\n  } else if (terserOptions.format) {\n    terserOptions.format.comments = buildComments(extractComments, terserOptions, extractedComments);\n  }\n\n  const result = await terserMinify({\n    [name]: input\n  }, terserOptions);\n  return { ...result,\n    extractedComments\n  };\n}\n/**\n * @param {string} options\n * @returns {InternalMinifyResult}\n */\n\n\nfunction transform(options) {\n  // 'use strict' => this === undefined (Clean Scope)\n  // Safer for possible security issues, albeit not critical at all here\n  // eslint-disable-next-line no-param-reassign\n  const evaluatedOptions =\n  /** @type {InternalMinifyOptions} */\n  // eslint-disable-next-line no-new-func\n  new Function(\"exports\", \"require\", \"module\", \"__filename\", \"__dirname\", `'use strict'\\nreturn ${options}`)(exports, require, module, __filename, __dirname);\n  return minify(evaluatedOptions);\n}\n\nmodule.exports.minify = minify;\nmodule.exports.transform = transform;"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;A;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;;;;;;;AC9nBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;;;;A;;A;;A","sourceRoot":""}